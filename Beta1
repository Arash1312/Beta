 elif cmd == "exit":
                break
            else:
                print("Unknown command")
    except KeyboardInterrupt:
        pass
    finally:
        controller.shutdown()
  parser = argparse.ArgumentParser()
    parser.add_argument("--broker", required=True)
    parser.add_argument("--port", type=int, default=1883)
    parser.add_argument("--command_topic", default="home/vacuum/command")
    parser.add_argument("--status_topic", default="home/vacuum/status")
    args = parser.parse_args()
    def connect(self):
        self.client.connect(self.broker, self.port, keepalive=60)
        t = threading.Thread(target=self.client.loop_fore


            payload = msg.payload.decode('utf-8')
            print(f"[STATUS] {msg.topic}: {payload}")
        except Exception as e:
            print("Error decoding status message:", e)
ver, daemon=True)
       
"""
mqtt_controller.py
Simple MQTT-based controller for robot vacuums that support MQTT or Home Assistant topics.
Usage:
    python mqtt_controller.py --broker 192.168.1.10 --topic home/vacuum/command
""" self.broker = broker
        self.port = port
        self.client = mqtt.Client(client_id=client_id)
        self.command_topic = command_topic
        self.status_topic = status_topic
        self.connected = False
        self._stop = False
        self.client.on_connect = self._on_connect
        self.client.on_message = self._on_message
        # optional: username/password
        # self.client.username_pw_set("user","pass")
import json
import timedef main():
  
import threading
import paho.mqtt.client as mqtt

class MQTTVacuumController:
    def __init__(self, broker, port=1883, command_topic="home/vacuum/command", status_topic="home/vacuum/status", client_id="vacuum-controller"):
       
        self.connected = True
        # subscribe to status
        client.subscribe(self.status_topic)
if __name__ == "__main__":
    main()#!/usr/bin/env python3
import argparse
    def send_command(self, command: dict):
        payload = json.dumps(command)
        print("Publishing:", payload)
        self.client.publish(self.command_topic, payload, qos=1)
  cmd = input("> ").strip().lower()
            if cmd == "start":
                controller.start_clean()
            elif cmd == "stop":
                controller.stop_clean()
            elif cmd == "dock":
                controller.return_to_base()
            elif cmd.startswith("goto "):
    def _on_message(self, client, userdata, msg):
        try:
    def _on_connect(self, client, userdata, flags, rc):
        print("MQTT connected with result code", rc)
 t.start()
        # wait for connection
        timeout = 5
        while not self.connected and timeout>0:
            time.sleep(0.2)
            timeout -= 0.2
        if not self.connected:
            raise RuntimeError("Failed to connect to MQTT broker")

    def start_clean(self):
        self.send_command({"action":"start"})

    def stop_clean(self):
        self.send_command({"action":"stop"})

    def return_to_base(self):
        self.send_command({"action":"dock"})

    def go_to_room(self, room_name):
        # requires robot to support named zones/rooms
        self.send_command({"action":"goto","room":room_name})

    def shutdown(self):
        self.client.disconnect()


    controller = MQTTVacuumController(args.broker, args.port, args.command_topic, args.status_topic)
    controller.connect()

    print("Commands: start / stop / dock / goto <room> / exit")
    try:
        while True:
          
                _, room = cmd.split(" ",1)
                controller.go_to_room(room)
           

